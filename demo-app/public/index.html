<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
    <!-- <script>
      // // arrow functions
      // const doIt = () => {

      // };

      // // function declaration
      // function doIt2() {

      // }

      // const doIt3 = function() {

      // };

      // function doIt(a, b, ...c) {
      //   console.log(a, b, c);
      // }

      // doIt(1, 2, 3, 4, 5);

      // legacy code
      var t = 2;

      // modern
      let y = 2; // t is mutable
      const s = 3; // s is not mutable

      // object literal
      const person = {
        firstName: 'Bob',
        lastName: 'Smith',
        // getFullName: function() {
        getFullName() {
          return this.firstName + ' ' + this.lastName;
        },
      };

      console.log(person.getFullName());

      const person2 = {
        firstName: 'Sally',
        lastName: 'Thompkins',
        getFullName: person.getFullName,
      };

      console.log(person2.getFullName());

      console.log(person.getFullName === person2.getFullName);
    </script> -->

    <!-- <script>
      function doIt(fn) {
        console.log('a');
        fn('b');
      }

      
      
      doIt(function displayMessage(msg) {
        console.log(msg);
      });


    </script> -->

    <!-- <script>
      function outer() {
        let t = 2;

        setTimeout(function setTto4() {
          console.log('a');
          t = 4;
        }, 2000);

        return function inner() {
          console.log(t);
        };
      }

      const fn = outer();

      fn();

      setTimeout(function callInnerAgain() {
        console.log('b');
        fn();
      }, 4000);

      // console.dir(fn);
    </script> -->

    <!-- <script>
      // setTimeout(() => {
      //   console.log('a');
      // }, 0)

      // console.log('b');

      const delay = () => Math.floor(Math.random() * 1000) + 500;

      // setTimeout(() => {
      //     console.log('a');
      //     setTimeout(() => {
      //         console.log('b');
      //         setTimeout(() => {
      //             console.log('c');
      //         }, delay());
      //     }, delay());
      // }, delay());

      // Lab Exercise
      // Run the "allDone" function after all three setTimeouts complete.
      // Rules:
      // 1. You cannot wrap the allDone function in its own setTimeout
      // 2. All three setTimeouts must be called in the same task

      // let counter = 0;

      // function allDone() {
      //   console.log('all done');
      // }

      // counter++;
      // setTimeout(() => {
      //   console.log('a');
      //   counter--;
      //   if (counter === 0) {
      //     allDone();
      //   }
      // }, delay());

      // counter++;
      // setTimeout(() => {
      //   console.log('b');
      //   counter--;
      //   if (counter === 0) {
      //     allDone();
      //   }
      // }, delay());

      // counter++;
      // setTimeout(() => {
      //   console.log('c');
      //   counter--;
      //   if (counter === 0) {
      //     allDone();
      //   }
      // }, delay());
    </script> -->

    <!-- <script>
      // class Promise {

      //   constructor(fn) {

      //     this.thenFns = [];
      //     this.catchFns = [];

      //     const resolveFn = (data) => {
      //       this.thenFns.forEach(fn => fn(data));
      //     };

      //     const rejectFn = (data) => {
      //       this.catchFns.forEach(fn => fn(data));
      //     };

      //     fn(resolveFn, rejectFn);
      //   }

      //   then(fn) {
      //     this.thenFns.push(fn);
      //   }

      //   catch(fn) {
      //     this.catchFns.push(fn);
      //   }

      // }

      const delay = () => Math.floor(Math.random() * 1000) + 500;

      console.log('1. creating promise');
      const p = new Promise((resolve, reject) => {
        console.log('2. call settimeout');
        setTimeout(() => {
          console.log('5. call resolve with data');
          reject('a');
        }, delay());
      });

      console.log('3. call then, passing a function ref');
      p.then(result => {
        console.log('6. output result');
        console.log(result);
      }).catch(result => {
        console.log('something went wrong: ' + result);
      });

      console.log('4. output waiting...');
      console.log('waiting');
    </script> -->

    <!-- <script>
      // const myFetch = url => {
      //   return new Promise(resolve => {
      //     const xhr = new XMLHttpRequest();

      //     xhr.addEventListener('readystatechange', () => {
      //       if (xhr.status === 200 && xhr.readyState === 4) {
      //         resolve(JSON.parse(xhr.responseText));
      //       }
      //     });

      //     xhr.open('GET', url);
      //     xhr.send();
      //   });
      // };

      // Lab Exercise

      // Using promises to implement the myFetch function... Do not worry about error handling.
      // I should be able to paste the following line of code, as is, in your code and is should work.

      const getCars = () =>
        fetch('http://localhost:3060/cars').then(res => res.json());

      const getColors = () =>
        fetch('http://localhost:3060/colors').then(res => res.json());

      // multiple operations at once
      Promise.all([getCars(), getColors()]).then(results => {
        console.log(results);
      });
    </script> -->
    <!-- <script>
      'use strict';

      function doIt() {
        console.log(this);
      }

      doIt();

      window.doIt();

      const o = {
        id: 2,
        doIt: doIt,
      };

      o.doIt();

      console.log(window.doIt === o.doIt);

      function setTimeout(fn, delay) {
        // some delay
        fn();
      }

      setTimeout(() => o.doIt(), 2000);
    </script> -->
  </body>
</html>
